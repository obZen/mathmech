\documentclass[]{article}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[russian]{babel}
\usepackage{hyperref}
\usepackage[left=0.5cm, right=0.5cm, top=1cm, bottom=2cm, bindingoffset=0cm]{geometry}
\usepackage{listings}
%opening
\title{Архитектура ЭВМ}
\author{}
\date{}

\begin{document}
\maketitle

\section{Введение}
	\begin{itemize}
		\item Жёсткая архитектура (данные и программные код прошиты в железе и защищены от записи)
		\item Архитектура с программным управлением. Впервые описал в 1943 году Тьюринг в виде машины Тьюринга.
	\end{itemize}
	
	\subsection{Понятие операционной системы}
		\begin{itemize}
			\item Расширение архитектуры ЭВМ
			\item Разделение ресурсов (во времени, например принтер; в пространстве, например RAM, жесткий диск)
		\end{itemize}
	\subsection{Принципы фон-Неймана}
		\subsubsection{Двоичное кодирование}
			Все данные представлены в виде двоичных чисел.
			
			Система счисление реализуется регистрами, состоящие из набора триггеров. Если в регистре $n$-разрядов, то $m=nx$, где $x$ - основание системы счисления, а $m$ - общее число состояний (или выходов).\\
			Из $m=nx \Rightarrow n = m/x$, с помощью $n$ разрядов можно закодировать алфавит мощностью $N = X^n = X^(m/x)$. Если представить $N$, как функцию $f(X), m=const$, то наиболее оптимальная система счисление $X$ будет являться точкой максимума этой функции, которая равна ближайшему целому числу от $e = 2,71\dots$, т.е. система счисления с основанием 3. Но, так как реализация троичной с.с. довольно затруднительна, было принято решение кодировать данные в двоичной системе счисления. 
			
			Алсо, существует троичная ЭВМ - Сетунь, разработанная в МГУ.
			
			1 байт = 8 битам. Причины выбора именно такого количества битов:
			\begin{itemize}
				\item Использование в IBM кодирования BCD (binary-coded decimal)
				\item Все основные символы можно закодировать с помощью 8 битов (Всего 255 символов)
				\item Ближайшая удобная степень числа 2
			\end{itemize}
			Минимально адресуемая область памяти - машинное слово (word), которое состоит из двух байтов. В архитектуре intel байты машинного слова при передаче и хранении идут в обратном порядке (т.е. сначала старший байт, потом младший). При передаче данных через сеть машинного слова, байты расположены в прямом порядке.\\
			Передача по сети:\\
			$\begin{array}{|c|c|}
				\overbrace{0000001}^1 & \overbrace{0^70^60^50^40^30^20^10^0}^0\\
			\end{array}$\\
			Расположение байтов машинного слова в архитектуре Intel:\\
			$\begin{array}{|c|c|}
				\overbrace{0000001}^0 & \overbrace{0000000}^1\\
			\end{array}$
		
		\subsubsection{Программное управление}
			Central processor unit (CPU) состоит из арифметико-логического устройства (АЛУ) и управляющего устройства (УУ), который содержит специальный регистр $Instruction position (IP)$, в котором хранится адрес команды, подлежащей выборке из оперативной памяти (Random access memory (RAM). CPU соединен с оперативной памятью с помощью \textit{системной шины}.\\
			Цикл CPU:\\
			\begin{enumerate}
				\item Извлечение команды по адресу в IP
				\item Декодирование команды
				\item Выполнение
				\item Переход к следующей команде
			\end{enumerate}
			
			\textit{Системная шина (bus)} - физически, провода, соединяющие CPU, RAM и прочие устройства ЭВМ. Существует отдельно шина адреса, шина данных и шина управления. Когда говорят о разрядности архитектуры, то имеют ввиду разрядность шины данных, т.е. число битов, используемых для кодирования данных, которые можно передать по системной шине.
		
		\subsubsection{Однородность памяти}
			Программы и данные хранятся в одной и той же памяти. Поэтому ЭВМ не различает, что хранится в данной ячейке памяти — число, текст или команда. Над командами можно выполнять такие же действия, как и над данными.
			
		\subsubsection {Адресуемость памяти}
			Структурно основная память состоит из пронумерованных ячеек; процессору в произвольный момент времени доступна любая ячейка. Отсюда следует возможность давать имена областям памяти, так, чтобы к хранящимся в них значениям можно было бы впоследствии обращаться или менять их в процессе выполнения программы с использованием присвоенных имен.

\part{Операционные системы}
	\section{Этапы развития ОС}
	1945 - 1953 г.г. ЭВМ I поколения.\\
	1995 - 1965 г.г. Появление транзисторов, перфокарт, операционных систем пакетной обработки.\\
	1965 - 1980 г.г. Появление интегральных схем, среди О.С. появляется многозадачность (аппаратное разделение памяти), первые попытки создать универсальный компьютер (IBM разработала совместимую между собой серию компьютеров разной мощности: IBM System 360/OS 360). Разделение времени.
	
	В MIT разработана OS TSS, поддерживающая разделение времени. Совместно с MIT, Bell labs, General Electric была разработна ОС Multics (?), поддерживающая безотказную работу и предоставляющая каждому процессу независимую память.
	
	Кенни Томпсон и Денис Ритчи в 1969 году разрабатывают ОС UNICS, в 1971 году выходит версия UNICS с открытым исходным кодом - UNIX. UNIX v.3 содержит компилятор C, в UNIX v.4 ядро переписано на язык C, в UNIX v.5 все программы переписаны на C. Далее UNIX разделился на AT\&T Unix System 5 и BSD (Berkley System Distribution).
	
	1980 год. IBM PC, PC/T, PC/AT, OS CP/M (Digital Research). Билл Гейтс создает DOS. Дуглас Элельбарт изобретает манипулятор "мышь", графический интерфейс пользователя. Стив Джобс Appale Macintosh, Mac OS - модификация BSD.
	В 1991 году Линукс Торвардс создает на базе Unix операционную систему Linux (только ядро), распространяемую бесплатно.
	\paragraph{POSIX}
		Для стандартизации взаимодействий с аппаратурой операционных систем IEEE был разработан стандарт POSIX.
	
	\section{Классификация ОС}
		\begin{enumerate}
			\item Однозадачные
			\item Разделение времени (многозадачность)
			\item О.С. реального времени
		\end{enumerate}
		
		\paragraph{Структура ядра}
		\begin{enumerate}
			\item Монолитное
			\item Микроядро (MacOS)
			\item Экзоядро
		\end{enumerate}
	\section{Процессы}
	\subsection{Основные понятия}
		\paragraph{Понятие задачи}
		Задача -  это совокупность программ, данных и инструкций по запуску.
		\paragraph{Понятие программы}
		Именованная область на диске, обладающая собственным состоянием.
		\paragraph{Процесс} Это область памяти RAM, в который находится все необходимое для выполнения задачи.
		 
		В ядре ОС существует менеджер процессов, выполняющий следующие задачи:
		\begin{enumerate}
			\item Загрузка
			\item Выделение памяти
			\item Настройка адресов (relocation)
			\item Выгрузка
			\item Освобождение памяти
			\item Освобождение ресурсов
		\end{enumerate}
		
		Структура памяти процесса: 1) код, 2) константы + переменные, 3) Свободное место, 4) стек, 5) куча - свободная не распределенная память (heap)
		
		\paragraph{Представление строк в памяти}
		\begin{enumerate}
			\item C-строка, завершающаяся символом с кодом 0.
			\item В первом байте строки указана длина строки (ограничение в 255 символов)
		\end{enumerate}
		
		\paragraph{Глобальные переменные}
		\begin{enumerate}
			\item Инициализированные
			\item Под них не выделена память на жестком диске
		\end{enumerate}
		
		\paragraph{Локальные переменные}
		\begin{enumerate}
			\item Размещаются в стеке.
		\end{enumerate}
		
		\paragraph{Стек}
		Структура данных, поддерживающая две команды: pop (взять с вершины стека), push (положить на вершину стека). В памяти растет в сторону области памяти с константами и переменными. Стек реализуется регистром процессора, который указывает на вершину стека.
		
		\paragraph{Соглашение вызова} Соглашение о размещение параметров функции в стеке перед вызовом этой функции.
	\subsection{Работа с кучей}
		В языке C функции $malloc()$ и $free()$, в C++ $new$ и $delete$. Все операции выделения и освобождения памяти работают с ссылками - переменные содержащие адрес памяти.
	
		\paragraph{Алгоритмы выделения памяти}
		\begin{enumerate}
			\item Первый подходящий
			\item Наилучший подходящий
		\end{enumerate}
		
		Информация о свободных и занятых блоках кучи хранится в виде таблицы: адрес (начальный) | размер | статус
		
		При освобождении памяти необходимо объединить смежные свободные блоки.
		
		\paragraph{Типичные проблемы}
		\begin{enumerate}
			\item Утечки памяти
			\item Использование указателей на освобожденную область памяти
		\end{enumerate}
		Одним из вариантов решения является использование сборщиков мусора или умных указателей.
	\section{Компиляция программ}
		Файлы исходного кода передается препроцессору, который возвращает единый файл с исходным кодом (code.cpp, без ограничения общности). Файл code.cpp передается на вход компилятору, возвращающий текст на ассемблере, который преобразуется в объектный файл (program.obj - Windows, program.o - Unix), содержащий машинный код, константы и переменные, символьная информация и ссылки на другие библиотеки. Объектный файл и библиотеки передаются сборщику (линковщику), результатом работы которого является исполняющий файл.
		
		\paragraph{Структура исполняющего файла (.exe - windows)}
		\begin{enumerate}
			\item Информация для настройки программы в RAM: таблица релокации (список смещений от начала файла команд, требующих настройки адресов)
		\end{enumerate}
	\section{Поток}
		Потоки могут быть реализованы, только если операционной системой поддерживается многозадачность.
		
		\paragraph{Понятие потока}
		Поток - это процесс + состояние процесса + IP + использованные ресурсы. Процесс может находиться в одном из трех состояний: выполнение $\leftarrow$ ожидание $\leftarrow$ готовность $\leftrightarrow$ выполнение.
		
		\paragraph{Прерывания}
		В RAM есть таблица векторов прерываний (адресов процедур обработки прерываний). Источником регулярных внешних прерываний в ОС является таймер.
		
		\subsection{Менеджер потоков}
			\paragraph{Задачи}
			\begin{enumerate}
				\item Разблокировка потока (из состояние блокирован в состояние готов)
				\item Переключение потоков (из состояние готов в состояние работает)
			\end{enumerate}
		
		\subsection{Типы потоков}
			\begin{enumerate}
				\item Пакетные
				\item Интерактивные
				\item Потоки реального времени
			\end{enumerate}
		
		\subsection{Алгоритмы планирования интерактивных потоков}
			Кооперативная многозадачность (потоки переключаются только после того как работающий поток вернет управление системе).
			
			Вытесняющая многозадачность. Реализуется с помощью циклических очередей потоков или очередей с приоритетами.
			
			\paragraph{Квант времени}
				Количество времени выделяемое каждому потоку, пока его не переведут из состояния выполнения в состояние готов. Приоритет = f(остаток кванта). Чем ниже приоритет, тем реже переключаются на этот поток.
				
			\paragraph{Амортизация приоритетов}
			Необходимо время от времени восстанавливать приоритет на начальный уровень.
	
	\section{Задача синхронизации. Взаимодействие процессов.}
		\paragraph{Thread - нить} Поток в рамках одной программы, работающий параллельно с другими нитями.
		\paragraph{Транзакция} Набор операций, выполняемых как единое целое, называют транзакцией.
		\paragraph{Критическая секция}
		\begin{lstlisting}
			int n = 0; // Share variable
			f1() {
				while(true) { ++n; ++n; }
			}
			
			f2() {
				while(true) { if(n % 2 != 0) print(n); }
			}
			
			int main() {
				new thread(f1).start();
				new thread(f2).start(); 
			}
		\end{lstlisting}
		
		Раздел программы, работающей с общими данными или зависящей от них называют критической секцией.
		
		\paragraph{Проблемы}
		Два потока не должны одновременной находится в своих критических секциях. Поток должен выходить из критической секции. Поток вне критической секции не должен мешать другим потокам войти в свою критическую секцию.
		
		\paragraph{Решения}
		\begin{enumerate}
			\item Запретить прерывания (возможно только внутри ядра).
			\item Блокировка общих данных на время выполнения критической секции.
		\end{enumerate}
		
	\section{Управление памятью}
		С точки зрения  программы работать на прямую с памятью невозможно. Для программы существует некоторая \textit{модель памяти} (абстракция), выделяют следующие виды моделей: отсутствие модели, виртуальная память.
		
			\subsection{Отсутствие модели}
			Работа ведется на прямую с физической памятью.
			
			Возможные проблемы:
			\begin{enumerate}
				\item Разное расположение в памяти (решение: релокация при загрузке).
				\item Средства защиты
				\subitem Решение: использование базового регистра (адрес начала секции программного кода, данных, стека) и ограничительного регистра (адрес конца секции программного кода, данных, стека) (в intel не используется).
				\item Нехватка памяти
				\subitem Решение, если не хватает памяти для запуска нескольких программ одновременно: программу, которая не выполняется - выгрузить (свопинг)
				\subitem Решение, если не хватает памяти для запуска одной программы: загружать программу по частям - оверлайн.
			\end{enumerate}
			
			\subsection{Виртуальная память}
			Виртуальная память на самом деле не существует, а является абстракцией в ОС для организации доступа к физической памяти программам. Ее делят на страничную и сегментную (каждой программе соответствует свой сегмент).
			
			\paragraph{Организация страничной виртуальной памяти}
			\begin{enumerate}
				\item Любой программе выделено некоторое адресное пространство, размер которого, обычно, соответствует разрядности шины данных для физической памяти, но может быть любым.ы
				\item Память делится на блоки (страницы) одинакового размера, равного степени двойки.
				\item Каждый адрес состоит из двух частей: номер страницы и смещение внутри этой страницы.
				\item У каждого процесса есть своя таблица страниц, у ОС есть общая таблица всех страниц. Таблица состоит из полей: бит отображения (показывает, отображена ли страница в физическую память), номер страницы (4 бита), смещение (12 бит), т.е. каждый адрес представляет из себя два байта.
			\end{enumerate}
			
			\paragraph{Хранение таблицы страниц}
			\begin{enumerate}
				\item В процессоре (самый быстрый способ, но самый дорогой)
				\item Целиком в памяти (на одно обращение к памяти, требуется одно обращение к таблице)
				\item Гибридное решение (TLB): принцип локальности, буфер часто используемых ссылок на страницы, ассоциативная память (реализован на аппаратном уровне), в процессоре есть два регистра: LDTR (Local Descriptor Table Registr) - хранит адрес расположения таблиц в памяти для текущего процесса, GDTR (Global DTR).
			\end{enumerate}
		
			\subsection{Сегментная виртуальная память}
			В центральном процессоре есть несколько базовых регистров, в сочетании со смещением определяется адрес в этом сегменте. 
			\begin{enumerate}
				\item \textit{CS} сегмент кода.
				\item \textit{SS} сегмент стека.
				\item \textit{DS} сегмент данных.
			\end{enumerate}
			Существует таблица сегмента в которой определяются: адрес начала и конца сегмента, уровень привилегий, права доступа (Read (r), write(w), execute(x)). Например, для CS разрешено только читать и исполнять, а SS только читать и писать.
			
			Сегменты позволяют защитить данные в оперативной памяти.
		\section{Ввод и вывод в ОС}
			\subsection{Классификация устройств}
			\paragraph{По типу}
			\begin{enumerate}
				\item Устройства ввода (сканер, мышь, клавиатура)
				\item Устройства вывода (монитор, принтер, плоттер)
				\item Коммуникация (модем)
				\item Запоминающие (SSD, HHD, CD, DVD, магнитная лента, магнитно-оптические накопители)
			\end{enumerate}
			\paragraph{По адресации}
			\begin{enumerate}
				\item Символьные (Побайтовая адресация)
				\item Блочная адресация (Способны адресовать только некоторую совокупность байтов - блок. Например, на ЖД блок равен 512 байтам)
			\end{enumerate}
			\paragraph{По способу доступа}
			\begin{enumerate}
				\item Произвольный
				\item Последовательный
			\end{enumerate}
			
			\subsection{Порт I/O}
			Современные устройства состоят из двух частей: механической (для ОС неважна ее реализация) и контроллер, который представляет из себя программно-аппаратное устройство, передающие в ОС информацию о состоянии устройства и обеспечивающий обмен данными между ОС и устройством.
			
			\textit{Порт I/O} представляет из себя число, обозначающие некоторое адресное пространство, через которое происходит обмен данными между ОС и устройством. Существует шина I/O через которую передают данные, команды и статус. 
			
				\subsubsection{Организация обмена данными}
				\begin{enumerate}
					\item Отдельное адресное пространство памяти и I/O. В процессоре реализуются специальные команды: \begin{lstlisting}
						in [register] [port]
						out [register] [port]
					\end{lstlisting}
				\item Совместное адресное пространство.
				\item Гибридное адресное пространство, когда часть памяти выделяют для портов I/O.
				\end{enumerate}
			
			\subsection{Синхронный и асинхронный ввод/вывод}
			Синхронный ввод вывод заключается в активном ожидании, т.е. ОС ждет команды пока устройство не готово.
			
			При асинхронном I/O управление в программу возвращается сразу. Пример: Веб-технология AJAX, которая позволяет делать скрытые запросы на сервер без обновления всего веб-документа.
			\begin{lstlisting}
				var x = XMLHTTPRequest();
				// Handler. It run when control return in program
				x.onReadyStateChange = function { /* some code */ };
				x.open("e1.ru", true);
				x.send()
			\end{lstlisting}
			В операционных системах устройство, завершив операцию, сигнализирует об этом (вызывает прерывание).
			\subsection{Драйверы}
			 С точки зрения ОС, драйвер реализует API этой системы для взаимодействия с устройствами (скрывает детали реализации взаимодействия с устройствами). Обычно, драйвер работает в адресном пространстве ядра ОС.
			 
			 \subsection{Подключение драйверов к программе}
			 \begin{enumerate}
			 	\item \textit{Статическая сборка}. Собрать ядро ОС, указав какие драйверы (библиотеки) подключать, а какие нет. При добавлении новых устройств требуется перекомпиляция ядра. Преимущество в том, что используется только тот код, который используется, что в свою очередь позволяет снизить потребляемую память.
			 	\item \textit{Динамическое подключение}. Технология Plug and play - динамическая загрузка в некоторый момент времени (при старте и процессе работе ОС). В частности, в ОС Linux, можно просмотреть список текущих загруженных модулей ядра (драйверов), с помощью команд: \textit{lsmod} и \textit{insmod}.
			 	\item \textit{Горячая загрузка}. Подключение устройств через шину USB без перезагрузки компьютера. устройство, поддерживающие USB реализует некоторые функции по стандарту, что позволяет взаимодействовать с ОС.
			 \end{enumerate}
			 
			 \subsection{Жесткий диск}
			 Работа жестких дисков с точки зрения операционной системы.
			 
			 \subsubsection{Механика}
			 Цилиндр с несколькими тысячами дорожек, на которых храниться информация. Каждая дорожка состоит из нескольких секторов (с программной точки зрения 512 байт, на твердотельных 4 Кбайт), который представляет из себя блок с данными перед которыми идет номер сектора, а перед ним преамбула, после данных идет контрольная сумма (позволяет узнать верность считанных данных, и восстановить их при необходимости):\\
			 \begin{tabular}{|c|c|c|c|}
			 	Преамбула & Номер сектора & Данные & Контрольная сумма
			 \end{tabular}
			 
			 Изначально на жестком диске присутствовала адресация: CHS (Cylinder Head Sector).
			 В современных жестких дисках используется адресация: LBA (Logical Block Address), преобразует некоторый понятный ОС адрес (\#1023) во внутренние представление (Дорожка, сектор).
			 
			 \subsubsection{Надежность}
			 Надежность жестких дисков обеспечивается за счет избыточности хранимой информации: решение RAID (Rendindand Array ...).
			 
			 \begin{enumerate}
			 	\item \textit{RAID-0} (Зеркало). Есть некоторая последовательность исходных данных, которые равномерно распределяются по двум жестким дискам. Зеркало позволяет повысить скорость работы с жестким диском, но не надежность хранения данных! С точки зрения ОС, для программ не существует двух жестких, физическая реализация скрывается.
			 	
			 	\item \textit{RAID-1} Некоторая последовательность исходных данных полностью дублируются на другом жестком диске.
			 	
			 	\item \textit{RAID-5}  Данные с одного жесткого диска равномерно распределяется на трех или четырех жестких дисках, и на не котором другом диске храниться контроль (например, логическая операция исключающего или)
			 	
			 	\item \textit{RAID-6} Позволяет выжить, если выйдет из строя два жестких диска.
			 \end{enumerate}
			 
			 Решение EVA: в стандартом телекоммуникационном шкафу храниться очень много жестких дисков.
			 
			 \subsubsection{Логическая структура}
			 Жесткий диск разделен на логические составляющие - разделы, которые могут использоваться различными ОС и иметь разный тип файловой системы:
			 \begin{tabular}{|c|c|c|}
				Раздел \#1 & \dots & Раздел \#N
			 \end{tabular}
			
			В самом первом секторе жесткого диска находиться \textit{структура разделов} и \textit{программа загрузки (boot)}. Первый сектор имеет название MBR (Master Boot Record).
			
			\paragraph{BIOS} Базовая система ввода и вывода, которая выполняет подготовку компьютера при старте. При старте BIOS загружается в память и начинает выполнять некоторые процедуры, например штатное тестирование системы (POST - Power On Self Test). 
			
			CMOS - энергонезависимая память BIOS, в которой хранится различные параметры конфигурации (место, откуда загружать ОС), текущее время.
			
			Процедура BOOT STRAP начальной загрузки.
			
			\paragraph{Таблица разделов}
			Каждый раздел характеризуется следующей записью:
			\begin{enumerate}
				\item Начало раздела
				\item Конец раздела
				\item Флаги (активность, является ли раздел с ОС)
				\item Тип файловой системы
			\end{enumerate}
			
			Один из разделов может иметь тип расширенный раздел", который может иметь структуру из четырех разделов.
			
			ОС DOS позволяет разбить жесткий диск на основной и расширенный разделы, в последнем можно сделать до 4 логических дисков. Windows позволяет делать сколько угодно основных и расширенных (которые могут включать в себя другие расширенные) дисков.
	\section{Файловая система}
		Задача: какое место занято/свободно
		%todo таблица размещения файлов
		%todo кластер жд
		Файловая система: каталог (имя файла/размер/дата/флаги/ссылка на таблицу (связанный список) с данными о размещении файлов в кластерах)
		
		Операции над файлами: создание (занесение записи в каталог), открытие (загрузка файлов в память), удаление (состоит из двух частей: 1. удаление из каталога (необязательно физическое удаление записи с носителя) флаг "удален" (в FAT меняется первый символ из имени файла), 2. очистка цепочки кластеров)
		
		Проблемы: потерянные кластеры (завершили очистку файлов в каталоге, но не очистили кластеры), две пересекающиеся цепочки кластеров.
		
		\paragraph{Решение проблем}
		\begin{enumerate}
			\item Устранить пост-фактум (при перезагрузке)
			\item Журналирование в файловой системе гарантирует, что некоторая последовательность будет выполнена целиком или не будет выполнена вообще (транзакция). Запись журнала в конечном итоге приводит к выполнению следующих действий: чтение, выполнение, контроль. Если операция была выполнена целиком, то где-то у этой записи ставиться флаг (выполнен?). Если произошел сбой, то во время исправления ошибок запись будет выполняться еще раз. Все операции в журнале должны быть повторяемыми.	
			
			Примеры ФС: ext3 в Linux, NTFS
		\end{enumerate}
		
		\paragraph{Дополнительные возможности файловой системы}
		Кроме каталога файлов есть таблица с дополнительными произвольными атрибутами файла. Например, в NTFS таблица MFT (Master File Table). В этом случае каталог содержит ссылку на эту таблицу (как замена цепочки кластеров, например). Атрибуты, например, DATA (хранится цепочка кластеров, либо сам файл, если его размер очень мал), разрешение доступа, и любые другие атрибуты.
		
		Жесткие ссылки в ФС (hard link), мягкая ссылка (специальная запись в каталоге).
		
		\section{Разрешение доступа}
		\textit{Идентификация} - это присваивание имени чему-то или кому-то без подтверждения.
		\textit{Аутентификация} - проверка подлинности, осуществляется различными способами: общее знание (разделяемый секрет, лол), например, пароль; биометрическая аутентификация (отпечаток носа); многофакторная аутентификация (special for профессиональный параноик); одноразовая аутентификация (одноразовые пароли)
		\textit{Авторизация} - разрешение или не разрешение выполнения некоторых действий с некоторым объектом (например с файлом или каталогом). Разрешение или не разрешение некоторых действий субъекту.
		
		\paragraph{Хранение таблицы разрешений доступа в ОС}
		Для субъектов (список пользователей): таблица (SID/UID | Name | First Name - Last Name | Password (информация для аутентификации, храниться в виде хэша)) Объединение пользователей в кучи (говна) - группы.
		
		Второй вариант хранения: хранить только реально заполненные значения.
		
		Оптимизация: пользователи с однотипными разрешениями объединяются. Создание ролей.
		Вторая оптимизация: объединение одинаковых списков контроля доступа. Таблица уникальных ACL. 
\end{document}
